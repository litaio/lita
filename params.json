{"name":"Lita","tagline":"A multi-service chat bot with extendable behavior.","body":"# Lita\r\n\r\n![Lita](http://f.cl.ly/items/0c271a2P3k2V180B1R0X/lita.jpg)\r\n\r\n**Lita** is a chat bot written in Ruby with persistent storage provided by [Redis](http://redis.io/). It can connect to any chat service (given that there is an [adapter](#adapters) available for it) and can have new behavior added via [handlers](#handlers). The plugin system is managed with regular RubyGems and [Bundler](http://gembundler.com/).\r\n\r\nAutomate your business and have fun with your very own robot companion.\r\n\r\n## Features\r\n\r\n* Can work with any chat service\r\n* Simple installation and setup\r\n* Easily extendable with plugins\r\n* Data persistence with Redis\r\n* Built-in web server and routing\r\n* Support for outgoing HTTP requests\r\n* Group-based authorization\r\n* Configurable logging\r\n\r\n## Why?\r\n\r\nLita draws much inspiration from GitHub's fantastic [Hubot](http://hubot.github.com/), but has a few key differences and strengths:\r\n\r\n* It's written in Ruby.\r\n* It exposes the full power of Redis rather than using it to serialize JSON.\r\n* Is easy to develop and test plugins for with the provied [RSpec](https://github.com/rspec/rspec) extras. Lita strongly encourages thorough testing of plugins.\r\n* It uses uses the Ruby ecosystem's standard tools (RubyGems and Bundler) for plugin installation and loading.\r\n* It's thoroughly documented.\r\n\r\n## Is it any good?\r\n\r\nYes.\r\n\r\n## Dependencies\r\n\r\n* Ruby 2.0\r\n* Redis\r\n\r\n## Installation\r\n\r\nFirst, install the gem with `gem install lita`. This gives you access to the `lita` commmand. Run `lita help` to list available tasks.\r\n\r\nGenerate a new Lita instance by running `lita new NAME`. This will create a new directory called NAME (defaults to \"lita\") with a Gemfile and Lita configuration file.\r\n\r\n## Usage\r\n\r\nTo start your Lita instance, simply run `lita`. This will load up all the plugins (adapters and handlers) declared in your Gemfile, load any configuration you've defined (more on that later) and start the bot.\r\n\r\n## Adapters\r\n\r\nThe core Lita gem by itself doesn't do much. To make real use of it, you'll want to install an adapter gem to allow Lita to connect to the chat service of your choice. Find the gem for the service you want to use on [the list of adapters](https://github.com/jimmycuadra/lita/wiki/Adapters), then add it to your Gemfile. For example:\r\n\r\n``` ruby\r\ngem \"lita-hipchat\"\r\n```\r\n\r\nAdapters will likely require some configuration to be able to connect. See the documentation for the adapter for details.\r\n\r\nWithout installing an adapter, you can use the default shell adapter to chat with Lita in your terminal. Lita doesn't respond to many messages by default, however, so you'll want to add some new behavior to Lita via handlers.\r\n\r\n## Handlers\r\n\r\nHandlers are gems that add new behavior to Lita. They are responsible for listening for incoming messages and responding to them appropriately. Find the handler gems you want for your bot on [the list of handlers](https://github.com/jimmycuadra/lita/wiki/Handlers), then add them to your Gemfile. For example:\r\n\r\n``` ruby\r\ngem \"lita-karma\"\r\n```\r\n\r\n## Configuration\r\n\r\nTo configure Lita, edit the file `lita_config.rb` generated by the `lita new` command. This is just a plain Ruby file that will be evaluated when the bot is starting up. A Lita config file looks something like this:\r\n\r\n``` ruby\r\nLita.configure do |config|\r\n  config.robot.name = \"Sir Bottington\"\r\n  config.robot.mention_name = \"bottington\"\r\n  config.robot.adapter = :example_chat_service\r\n  config.adapter.username = \"bottington\"\r\n  config.adapter.password = \"secret\"\r\n  config.redis.host = \"redis.example.com\"\r\n  config.handlers.karma.cooldown = 300\r\n  config.handlers.google_images.safe_search = :off\r\nend\r\n```\r\n\r\nThe main config objects are:\r\n\r\n* `robot` - General settings for Lita.\r\n  * `name` (String) - The display name the bot will use on the chat service. Default: `\"Lita\"`.\r\n  * `mention_name` (String) - The name the bot will look for in messages to determine if the message is being addressed to it. Usually this is the same as the display name, but in some cases it may not be. For example, in HipChat, display names are required to be a first and last name, such as \"Lita Bot\", whereas the mention system would use a name like \"LitaBot\". Default: `Lita.config.robot.name`.\r\n  * `adapter` (Symbol, String) - The adapter to load. Default: `:shell`.\r\n  * `log_level` (Symbol, String) - The severity level of log messages to output. Valid options are, in order of severity: `:debug`, `:info`, `:warn`, `:error`, and `:fatal`. For whichever level you choose, log messages of that severity and greater will be output. Default: `:info`.\r\n  * `admins` (Array<String>) - An array of string user IDs which tell Lita which users are considered administrators. Only these users will have access to Lita's `auth` command. Default: `nil`.\r\n* `redis` - Options for the Redis connection. See the [Redis gem](https://github.com/redis/redis-rb) documentation.\r\n* `http` - Settings related to Lita's built-in web server.\r\n  * `port` (Integer) - The port the server should run on. Default: `8080`.\r\n  * `debug` (Boolean) - Set to true to display the web server's logs mixed in with Lita's own logs. Default: `false`.\r\n* `adapter` - Options for the chosen adapter. See the adapter's documentation.\r\n* `handlers` - Handlers may choose to expose a config object here with their own options. See the handler's documentation.\r\n\r\nIf you want to use a config file with a different name or location, invoke `lita` with the `-c` option and provide the path to the config file.\r\n\r\n## Authorization\r\n\r\nAccess to commands can be allowed for only certain users by means of authorization groups. Users set as admins (by adding their user IDs to the `config.robot.admins` array in Lita's configuration) have access to two commands:\r\n\r\n```\r\nLita: auth add joe committers\r\nLita: auth remove joe committers\r\n```\r\n\r\nThe first command adds a user whose ID or name is \"joe\" to the authorization group \"committers.\" If the group doesn't yet exist, it is created. The second command removes joe from the group. Handlers can specify that a route (a method that matches an incoming message) requires that the user sending the message be in a certain authorization group. See the section on writing handlers for more details.\r\n\r\n## Online help\r\n\r\nMessage Lita `help` for a list of commands it knows about. You can also message it `help FOO` to list only commands beginning with FOO.\r\n\r\n## Shell adapter\r\n\r\nLita ships with one adapter for use directly in the shell. Simply type text at the input to send messages, and Lita will respond with any registered handlers. The shell adapter has one configuration attribute:\r\n\r\n* `private_chat` (Boolean) - If true, all messages will be treated as though they were sent in a private chat, so they will be considered commands even when not prefixed with the bot's name. Default: `false`.\r\n\r\n## Writing an adapter\r\n\r\nAn adapter is a packaged as a RubyGem. The adapter is a class that inherits from `Lita::Adapter`, implements a few required methods, and is registered by calling `Lita.register_adapter(:symbol_that_identifies_the_adapter, TheAdapterClass)`.\r\n\r\n### Example\r\n\r\nHere is a bare bones example of an adapter for the fictious chat service, FancyChat.\r\n\r\n``` ruby\r\nmodule Lita\r\n  module Adapters\r\n    class FancyChat < Adapter\r\n      # Optional. Makes the bot produce an error message and quit upon start up\r\n      # if `config.adapter.username` or `config.adapter.password` are not set.\r\n      require_configs :username, :password\r\n\r\n      # Connects to the chat service and dispatches incoming messages to a\r\n      # Lita::Robot instance.\r\n      def run\r\n      end\r\n\r\n      # Sends a message from the robot to a user or room on the chat service.\r\n      def send_messages(target, strings)\r\n      end\r\n\r\n      # Sets the topic for a chat room.\r\n      def set_topic(target, topic)\r\n      end\r\n\r\n      # Does any clean up necessary when disconnecting from the chat service.\r\n      def shut_down\r\n      end\r\n    end\r\n\r\n    Lita.register_adapter(:fancy_chat, FancyChat)\r\n  end\r\nend\r\n```\r\n\r\nIt's important to note that each adapter should employ its own thread or event mechanism so that incoming messages can still be processed even while a handler is processing a previous message.\r\n\r\nFor more detailed examples, check out the built in shell adapter, [lita-hipchat](https://github.com/jimmycuadra/lita-hipchat), or [lita-irc](https://github.com/jimmycuadra/lita-irc). See the API documentation for the exact methods and signatures adapters must implement.\r\n\r\n## Writing a handler\r\n\r\nA handler is packaged as a RubyGem. A handler is a class that inherits from `Lita::Handler` and is registered by calling `Lita.register_handler(TheHandlerClass)`. There are two components to a handler: route definitions, and the methods that implement those routes. There are both chat routes and HTTP routes available to handlers.\r\n\r\n### Chat routes\r\n\r\nTo define a route, use the class method `route`:\r\n\r\n``` ruby\r\nroute /^echo\\s+(.+)/, :echo\r\n```\r\n\r\n`route` takes a regular expression that will be used to determine whether or not an incoming message should trigger the route, and the name of the method that should be called when this route is triggered. `route` takes a few additional options:\r\n\r\n* `:command` (Boolean) - If set to true, the route will only trigger when \"directed\" at the robot. Directed means that it's sent via a private message, or the message is prefixed with the bot's name in some form (optionally prefixed with an @, and optionally followed by a colon or comma and white space). This prefix is stripped from the message body itself, but `Lita::Message#command?` available in handlers can be used if you need to determine whether or not a message was a command after it's been routed. Default: `false`.\r\n* `:restrict_to` (Symbol, String, Array<String, Symbol>) - Authorization groups necessary to trigger the route. The user sending the message must be a member of at least one of the supplied groups. See the section on authorization for more information. Default: `nil`.\r\n* `:help` (Hash<String>) - A map of example invocations of the route and descriptions of what they do. These values will be used to generate the listing for the built-in \"help\" handler. The robot's mention name will automatically be added to the front of the example if the route is a command. Default: `{}`.\r\n\r\nHere is an example of a route declaration with all the options:\r\n\r\n``` ruby\r\nroute /^echo\\s+(.+)/, to: :echo, command: true, restrict_to: [:testers, :committers], help => {\r\n  \"echo FOO\" => \"Replies back with FOO.\"\r\n}\r\n```\r\n\r\nEach method that is called by a route takes one argument, a `Lita::Response` object. This object has the following useful methods:\r\n\r\n* `reply` - Sends one or more string messages back to the source of the original message, either a private message or a chat room.\r\n* `matches` - An array of regular expression matches obtained by calling `body_of_message.scan(route_regex)`.\r\n* `args` - The user's message as an array of strings, as it would be parsed by `Shellwords.split`. For example, if the message was \"Lita: auth add joe committers\", calling `args` would return `[\"add\", \"joe\", \"committers\"]`. (\"auth\" is considered the command and so is not included in the arguments.) This is very handy for commands that take arguments in a way similar to how a UNIX shell would work.\r\n* `message` - A `Lita::Message` object for the incoming message.\r\n* `user` - A `Lita::User` object for the user who sent the message.\r\n\r\nAdditionally, handlers have access to these top-level methods:\r\n\r\n* `robot` - Direct access to the currently running `Lita::Robot` object.\r\n* `redis` - A `Redis::Namespace` object which provides each handler with its own isolated Redis store, suitable for many data persistence and manipulation tasks.\r\n* `http` - A `Faraday::Connection` object for making HTTP requests. Takes an optional hash of options and optional block which are passed on to [Faraday](https://github.com/lostisland/faraday).\r\n\r\n### HTTP routes\r\n\r\nIn addition to chat routes, handlers can also define HTTP routes for the built-in web server. This is done with the class-level `http` method. `http` returns a `Lita::HTTPRoute` object, which has methods for the most common HTTP methods. These methods take two arguments: the path for the route, and the name of the method that it will invoke as a symbol. The callback method takes two arguments: a `Rack::Request` and a `Rack::Response`. For example:\r\n\r\n``` ruby\r\nhttp.get \"/foo/bar\", :baz\r\n\r\ndef baz(request, response)\r\n  response.body = \"Hello, world!\"\r\nend\r\n```\r\n\r\n### Handler-specific configuration\r\n\r\nIf you want your handler to expose config settings to the user, use the class-level `default_config` method. This method accepts a single config object as an argument, which will be exposed to the user as `Lita.config.handlers.your_handler_namespace`.\r\n\r\n``` ruby\r\nmodule Lita\r\n  module Handlers\r\n    class HandlerWithConfig < Handler\r\n      def self.default_config(config)\r\n        config.enabled = true\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nLita.config.handlers.handler_with_config.enabled # => true\r\n```\r\n\r\n### Examples\r\n\r\nHere is a basic handler which simply echoes back whatever the user says.\r\n\r\n``` ruby\r\nmodule Lita\r\n  module Handlers\r\n    class Echo < Handler\r\n      route /^echo\\s+(.+)/, :echo, help: { \"echo FOO\" => \"Echoes back FOO.\" }\r\n\r\n      def echo(matches)\r\n        response.reply(response.matches)\r\n      end\r\n    end\r\n\r\n    Lita.register_handler(Echo)\r\n  end\r\nend\r\n```\r\n\r\nHere is a handler that tells a user who their United States congressional representative is based on zip code with data from a fictional HTTP API. The results are saved in the handler's namespaced Redis store to save HTTP calls on future requests.\r\n\r\n``` ruby\r\nmodule Lita\r\n  module Handlers\r\n    class Representative < Handler\r\n      route /representative\\s+(\\d{5})/, :lookup, command: true, help: {\r\n        \"representative ZIP_CODE\" => \"Looks up the United States congressional representative for your zip code.\"\r\n      }\r\n\r\n      def lookup(response)\r\n        zip = response.matches[0][0]\r\n        rep = redis.get(zip)\r\n        rep = get_rep(zip) unless rep\r\n        response.reply \"The representative for #{zip} is #{rep}.\"\r\n      end\r\n\r\n      private\r\n\r\n      def get_rep(zip)\r\n        http_response = http.get(\r\n          \"http://www.example.com/api/represenative\",\r\n          zip_code: zip\r\n        )\r\n\r\n        data = MultiJson.load(http_response.body)\r\n        rep = data[\"representative\"][\"name\"]\r\n        redis.set(zip, data[\"representative\"][\"name\"])\r\n        rep\r\n      end\r\n    end\r\n\r\n    Lita.register_handler(Representative)\r\n  end\r\nend\r\n```\r\n\r\nFor more detailed examples, check out the built in authorization, help, and web handlers, or external handlers [lita-karma](https://github.com/jimmycuadra/lita-karma) and [lita-google-images](https://github.com/jimmycuadra/lita-google-images). See the API documentation for exact specifications for handlers' methods.\r\n\r\n## Testing\r\n\r\nIt's a core philosophy of Lita that any plugins you write for your robot should be as thoroughly tested as any other program you would write. To make this easier, Lita ships with some handy extras for [RSpec](https://github.com/rspec/rspec) that make testing a handler dead simple. They require the full RSpec suite (rspec-core, rspec-expectations, and rspec-mocks) version 2.14 or higher, as they use the newer `expect(obj).to receive(:message)` syntax.\r\n\r\n### Testing handlers\r\n\r\nTo include Lita's RSpec extras for testing a handler, require \"lita/rspec\", then add `lita_handler: true` to the metadata for the example group.\r\n\r\n``` ruby\r\nrequire \"lita/rspec\"\r\n\r\ndescribe Lita::Handlers::MyHandler, lita_handler: true do\r\n  # ...\r\nend\r\n```\r\n\r\nThis provides the following:\r\n\r\n* All Redis interaction will be namespaced to a test environment and automatically cleared out before each example.\r\n* Lita's logger is stubbed to prevent log messages from cluttering up your test output.\r\n* Lita's configuration is cleared out before each example, so that the first call to `Lita.config` will start from the default configuration.\r\n* `Lita.handlers` will return an array with only the class you're testing (`described_class`).\r\n* Strings sent with `Lita::Robot#send_messages` will be pushed to an array accessible as `replies` so you can make expectations about output from the robot.\r\n* You have access to the following cached objects set with `let`: `robot`, `source`, and `user`. Note that these objects are instances of the real classes and not test doubles.\r\n\r\nThe custom helper methods are where `Lita::RSpec` really shines. You can test routes (both chat and HTTP routes) very easily using this syntax:\r\n\r\n``` ruby\r\nit { routes(\"some message\").to(:some_method) }\r\nit { routes_command(\"directed message\").to(:some_command_method) }\r\nit { doesnt_route(\"message\").to(:some_command_method) }\r\nit { routes_http(:get, \"/foo/bar\").to(:baz) }\r\nit { doesnt_route_http(:post, \"/foo/bar\").to(:baz) }\r\n```\r\n\r\n* `routes` - Sets an expectation that the given string will trigger the given method when overheard by the robot.\r\n* `routes_command` - Sets an expectation that the given string will trigger the given method when directed at the robot, either in a private message, or by prefixing a message in a chat room with the robot's mention name.\r\n* `doesnt_route` - Sets an expectation that is the inverse of the one set by `routes`. Also aliased to `does_not_route`.\r\n* `doesnt_route_command` - Sets an expectation that is the inverse of the one set by `routes_command`. Also aliased to `does_not_route_command`.\r\n* `routes_http` - Sets an expectation that an HTTP request with the given HTTP method and path will route to the given handler method.\r\n* `doesnt_route_http` - Sets an expectation that is the inverse of `routes_http`. Also aliased to `does_not_route_http`.\r\n\r\n**Note: These routing helpers bypass authorization for routes restricted to authorization groups.**\r\n\r\nTo send a message to the robot, use `send_message` and `send_command`. Then set expectations about the contents of the `replies` array.\r\n\r\n``` ruby\r\nit \"lets everyone know when someone is happy\" do\r\n  send_message(\"I'm happy!\")\r\n  expect(replies.last).to eq(\"Hey, everyone! #{user.name} is happy! Isn't that nice?\")\r\nend\r\n\r\nit \"greets anyone that says hi to it\" do\r\n  send_command(\"hi\")\r\n  expect(repliest.last).to eq(\"Hello, #{user.name}!\")\r\nend\r\n```\r\n\r\nIf you want to send a message or command from a user other than the default test user (set up for you with `let(:user)` by `Lita::RSpec`), you can invoke either method with the `:as` option, supplying a `Lita::User` object.\r\n\r\n``` ruby\r\nit \"lets everyone know that Carl is happy\" do\r\n  carl = Lita::User.create(123, name: \"Carl\")\r\n  send_message(\"I'm happy!\", as: carl)\r\n  expect(replies.last).to eq(\"Hey, everyone! Carl is happy! Isn't that nice?\")\r\nend\r\n```\r\n\r\n* `send_message(string, as: user)` - Sends the given string to the robot.\r\n* `send_command(string, as: user)` - Sends the given string to the robot, prefixing it with the robot's mention name.\r\n\r\n### Testing adapters or other code\r\n\r\nIf you use `lita: true` instead of `lita_handler: true` in the metadata for your example group, only a small subset of Lita's RSpec extras will be enabled:\r\n\r\n* All Redis interaction will be namespaced to a test environment and automatically cleared out before each example.\r\n* Lita's logger is stubbed to prevent log messages from cluttering up your test output.\r\n* Lita's configuration is cleared out before each example, so that the first call to `Lita.config` will start from the default configuration.\r\n\r\n## Deploying to Heroku\r\n\r\nThere are a few things worth mentioning when deploying an instance of Lita to Heroku:\r\n\r\n1. Your Procfile should contain one process: `web: bundle exec lita`.\r\n\r\n1. To use the Redis To Go add-on and the HTTP port set by Heroku, configure Lita like this:\r\n\r\n    ``` ruby\r\n    Lita.configure do |config|\r\n      config.redis.url = ENV[\"REDISTOGO_URL\"]\r\n      config.http.port = ENV[\"PORT\"]\r\n    end\r\n    ```\r\n\r\n1. Consider using a service like [Uptime Robot](http://www.uptimerobot.com/) to monitor your Lita instance and keep it from [sleeping](https://blog.heroku.com/archives/2013/6/20/app_sleeping_on_heroku) when running on a free dyno. `/lita/info` is a reliable path to hit from the web to keep it running.\r\n\r\n## API documentation\r\n\r\nComplete documentation for all of Lita's classes and methods can be found at [rdoc.info](http://rdoc.info/gems/lita/frames).\r\n\r\n## Try it out\r\n\r\nYou can chat with an instance of Lita on the Freenode IRC network in the channel `#litabot`. The bot's name is also *Litabot*.\r\n\r\n## History\r\n\r\nFor a history of releases, see the [Releases](https://github.com/jimmycuadra/lita/releases) page.\r\n\r\n## License\r\n\r\n[MIT](http://opensource.org/licenses/MIT)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}